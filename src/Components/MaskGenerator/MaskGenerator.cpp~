/*!
 * \file
 * \brief
 * \author lzmuda,,,
 */

#include <memory>
#include <string>

#include "MaskGenerator.hpp"
#include "Common/Logger.hpp"

#include <boost/bind.hpp>

namespace Processors {
namespace MaskGenerator {

MaskGenerator::MaskGenerator(const std::string & name) :
		Base::Component(name)  {

}

MaskGenerator::~MaskGenerator() {
}

void MaskGenerator::prepareInterface() {
	// Register data streams, events and event handlers HERE!
	h_onNewImage.setup(this, &MaskGenerator::onNewImage);
	registerHandler("onNewImage", &h_onNewImage);

	registerStream("in_img1", &in_img1);
	registerStream("in_img2", &in_img2);
	registerStream("out_img", &out_img);

}

bool MaskGenerator::onInit() {

	return true;
}

bool MaskGenerator::onFinish() {
	return true;
}

bool MaskGenerator::onStop() {
	return true;
}

bool MaskGenerator::onStart() {
	return true;
}

void MaskGenerator::onNewImage(){
    LOG(LTRACE) << "MaskGenerator::onNewImage\n";
    try {
        std::cout<<"Start\n";
        int val=0;
        img1 = in_img1.read();
        img2 = in_img2.read();
        cv::Size size1 = img1.size();
        cv::Size size2 = img2.size();
        std::cout<<"Clone to tmp\n";
	in_img2.create(size1, CV_8UC1);
	//tmp_img.create(size1, CV_8UC1);
        // Check the arrays for continuity and, if this is the case,
        // treat the arrays as 1D vectors
        std::cout<<"Set width\n";
        if (img1.isContinuous() && tmp_img.isContinuous()) {
        	size1.width *= size1.height;
        	size1.height = 1;
        }
        size1.width *= 3;
        std::cout<<"For\n";
        for (int i = 0; i < size1.height; i++)
        {
        	const uchar* rgb_p1 = img1.ptr <uchar> (i);
            const uchar* rgb_p2 = img2.ptr <uchar> (i);
            uchar* tmp_p = tmp_img.ptr <uchar> (i);
            int j, k = 0;
            for (j = 0; j < size1.width; j += 3)
            {
            	std::cout<<"For j\n";
            	uchar r = rgb_p1[j];
                uchar g = rgb_p1[j + 1];
                uchar b = rgb_p1[j + 2];
                val = 0;
                tmp_p[k] = val;
            }
        }
        std::cout<<"Write\n";
        out_img.write(tmp_img);
    }
    catch (Common::DisCODeException& ex) {
                   LOG(LERROR) << ex.what() << "\n";
                   ex.printStackTrace();
                   exit(EXIT_FAILURE);
           }
    catch (const char * ex) {
                   LOG(LERROR) << ex;
           }
   catch (...) {
                   LOG(LERROR) << "MaskGenerator::onNewImage failed\n";
           }
}


} //: namespace MaskGenerator
} //: namespace Processors
